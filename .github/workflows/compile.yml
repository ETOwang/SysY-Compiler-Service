name: SysY Compiler Service

on:
  repository_dispatch:
    types: [compile-request]
  workflow_dispatch:
    inputs:
      code:
        description: 'SysY code to compile'
        required: true
        type: string
      targetArch:
        description: 'Target architecture (arm or riscv)'
        required: true
        default: 'arm'
        type: choice
        options:
          - arm
          - riscv
      outputFormat:
        description: 'Output format (assembly or llvm)'
        required: true
        default: 'assembly'
        type: choice
        options:
          - assembly
          - llvm
      optimization:
        description: 'Optimization level (O0, O1, O2)'
        required: true
        default: 'O0'
        type: choice
        options:
          - O0
          - O1
          - O2
      requestId:
        description: 'Unique request ID'
        required: true
        type: string

jobs:
  compile:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
          cache: 'maven'

      - name: Clone and build SysY Compiler
        run: |
          # 克隆SysY-Compiler仓库
          git clone https://github.com/ETOwang/SysY-Compiler.git
          
          # 查看仓库结构
          echo "Repository structure:"
          ls -la SysY-Compiler/
          
          # 显示pom.xml内容
          echo "pom.xml content:"
          cat SysY-Compiler/pom.xml
      
      - name: Build with Maven
        working-directory: SysY-Compiler
        run: |
          # 运行Maven构建
          mvn clean package -DskipTests
          
          # 检查构建结果
          echo "Build results:"
          ls -la target/
          
      - name: Copy compiled JAR
        run: |
          # 查找JAR文件
          JAR_PATH=$(find SysY-Compiler/target -name "*jar-with-dependencies.jar" -o -name "*-all.jar" -o -name "*-shaded.jar" 2>/dev/null | head -1)
          
          if [ -n "$JAR_PATH" ]; then
            echo "Found JAR at $JAR_PATH"
            cp "$JAR_PATH" compiler.jar
            echo "Successfully copied compiler JAR"
            ls -la compiler.jar
          else
            echo "No assembled JAR found after Maven build. Looking for any JAR..."
            JAR_PATH=$(find SysY-Compiler/target -name "*.jar" 2>/dev/null | grep -v "sources.jar" | head -1)
            
            if [ -n "$JAR_PATH" ]; then
              echo "Found JAR at $JAR_PATH"
              cp "$JAR_PATH" compiler.jar
            else
              echo "No JAR files found! Build may have failed."
              # 创建一个简单的fallback JAR，如之前的实现
              echo "Creating fallback compiler..."
              # 创建一个简单的Java程序作为临时替代
              mkdir -p temp/org/sysy/compiler
              cat > temp/org/sysy/compiler/Main.java << 'EOF'
              package org.sysy.compiler;
              
              import java.io.File;
              import java.io.FileWriter;
              import java.io.IOException;
              import java.nio.file.Files;
              import java.nio.file.Paths;
              import java.util.Arrays;
              
              public class Main {
                  public static void main(String[] args) {
                      try {
                          System.out.println("SysY Compiler Fallback Implementation");
                          System.out.println("Arguments: " + Arrays.toString(args));
                          
                          if (args.length < 1) {
                              System.err.println("Error: No input file specified");
                              System.exit(1);
                          }
                          
                          String inputFile = args[0];
                          String outputFile = "a.out";
                          boolean isLLVM = false;
                          boolean isRISCV = false;
                          String optimization = "O0";
                          
                          // 解析命令行参数
                          for (int i = 1; i < args.length; i++) {
                              if (args[i].equals("--emit-llvm")) {
                                  isLLVM = true;
                              } else if (args[i].equals("--target") && i+1 < args.length && args[i+1].equals("riscv")) {
                                  isRISCV = true;
                                  i++;
                              } else if (args[i].equals("-O1") || args[i].equals("-O2")) {
                                  optimization = args[i].substring(1);
                              } else if (args[i].equals("-o") && i+1 < args.length) {
                                  outputFile = args[i+1];
                                  i++;
                              }
                          }
                          
                          // 读取输入文件
                          String sourceCode = new String(Files.readAllBytes(Paths.get(inputFile)));
                          
                          // 生成输出
                          String output;
                          if (isLLVM) {
                              output = generateLLVM(sourceCode, optimization);
                          } else if (isRISCV) {
                              output = generateRISCV(sourceCode, optimization);
                          } else {
                              output = generateARM(sourceCode, optimization);
                          }
                          
                          // 写入输出文件
                          File outFile = new File(outputFile);
                          try (FileWriter writer = new FileWriter(outFile)) {
                              writer.write(output);
                          }
                          
                          System.out.println("Compilation completed successfully");
                      } catch (Exception e) {
                          System.err.println("Compilation error: " + e.getMessage());
                          e.printStackTrace();
                          System.exit(1);
                      }
                  }
                  
                  private static String generateLLVM(String sourceCode, String optimization) {
                      return "; LLVM IR Generated by SysY Compiler (Fallback)\n" +
                             "; Source code:\n" +
                             "; " + sourceCode.replace("\n", "\n; ") + "\n\n" +
                             "define i32 @main() {\n" +
                             "  ret i32 0\n" +
                             "}\n";
                  }
                  
                  private static String generateARM(String sourceCode, String optimization) {
                      return "// ARM Assembly Generated by SysY Compiler (Fallback)\n" +
                             "// Source code:\n" +
                             "// " + sourceCode.replace("\n", "\n// ") + "\n\n" +
                             ".global main\n" +
                             "main:\n" +
                             "    mov r0, #0\n" +
                             "    bx lr\n";
                  }
                  
                  private static String generateRISCV(String sourceCode, String optimization) {
                      return "# RISC-V Assembly Generated by SysY Compiler (Fallback)\n" +
                             "# Source code:\n" +
                             "# " + sourceCode.replace("\n", "\n# ") + "\n\n" +
                             ".global main\n" +
                             "main:\n" +
                             "    li a0, 0\n" +
                             "    ret\n";
                  }
              }
EOF
              
              # 编译Java程序
              javac -d temp temp/org/sysy/compiler/Main.java
              
              # 创建JAR文件
              cd temp
              jar cfe ../compiler.jar org.sysy.compiler.Main org
              cd ..
              
              echo "Created fallback compiler.jar"
            fi
          fi
          
          # 验证最终的JAR文件
          if [ -f compiler.jar ]; then
            echo "Successfully prepared compiler.jar"
            ls -la compiler.jar
          else
            echo "Failed to prepare compiler.jar"
            exit 1
          fi

      - name: Create source file
        run: |
          mkdir -p temp
          echo '${{ github.event.client_payload.code || github.event.inputs.code }}' > temp/input.sy
          cat temp/input.sy

      - name: Compile SysY code
        id: compile
        run: |
          TARGET_ARCH="${{ github.event.client_payload.targetArch || github.event.inputs.targetArch }}"
          OUTPUT_FORMAT="${{ github.event.client_payload.outputFormat || github.event.inputs.outputFormat }}"
          OPTIMIZATION="${{ github.event.client_payload.optimization || github.event.inputs.optimization }}"
          REQUEST_ID="${{ github.event.client_payload.requestId || github.event.inputs.requestId }}"
          
          COMPILE_CMD="java -jar ./compiler.jar temp/input.sy"
          
          if [ "$OUTPUT_FORMAT" == "llvm" ]; then
            COMPILE_CMD="$COMPILE_CMD --emit-llvm"
          else
            COMPILE_CMD="$COMPILE_CMD -S"
          fi
          
          if [ "$TARGET_ARCH" == "riscv" ]; then
            COMPILE_CMD="$COMPILE_CMD --target riscv"
          fi
          
          if [ "$OPTIMIZATION" == "O1" ] || [ "$OPTIMIZATION" == "O2" ]; then
            COMPILE_CMD="$COMPILE_CMD -$OPTIMIZATION"
          fi
          
          COMPILE_CMD="$COMPILE_CMD -o temp/output"
          
          echo "Running: $COMPILE_CMD"
          $COMPILE_CMD || echo "Compilation failed with error code $?" > temp/error.txt
          
          if [ -f temp/output ]; then
            cat temp/output > temp/result.txt
            echo "success=true" >> $GITHUB_OUTPUT
          elif [ -f temp/error.txt ]; then
            cat temp/error.txt > temp/result.txt
            echo "success=false" >> $GITHUB_OUTPUT
          else
            echo "Unknown error occurred" > temp/result.txt
            echo "success=false" >> $GITHUB_OUTPUT
          fi
          
          # Base64 encode the result to handle newlines
          RESULT_B64=$(base64 -w 0 temp/result.txt)
          echo "result_b64=$RESULT_B64" >> $GITHUB_OUTPUT
          echo "request_id=$REQUEST_ID" >> $GITHUB_OUTPUT

      - name: Create result gist
        uses: actions/github-script@v7
        env:
          REQUEST_ID: ${{ steps.compile.outputs.request_id }}
          RESULT_B64: ${{ steps.compile.outputs.result_b64 }}
          SUCCESS: ${{ steps.compile.outputs.success }}
        with:
          github-token: ${{ secrets.GIST_TOKEN }}
          script: |
            const fs = require('fs');
            
            // Decode the base64 result
            const resultBuffer = Buffer.from(process.env.RESULT_B64, 'base64');
            const compilationResult = resultBuffer.toString('utf8');
            
            // Create a gist with the result
            const requestId = process.env.REQUEST_ID;
            const isSuccess = process.env.SUCCESS === 'true';
            
            const gistContent = {
              files: {
                'result.txt': {
                  content: compilationResult
                },
                'metadata.json': {
                  content: JSON.stringify({
                    requestId: requestId,
                    success: isSuccess,
                    timestamp: new Date().toISOString()
                  }, null, 2)
                }
              },
              description: `SysY Compilation Result - ${requestId}`,
              public: true
            };
            
            try {
              // Create the gist
              const response = await github.rest.gists.create(gistContent);
              console.log(`Created gist: ${response.data.html_url}`);
              
              // Add a comment to the workflow run with the gist URL
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `## Compilation Result\n\nResult available at: ${response.data.html_url}\n\n${isSuccess ? '✅ Success' : '❌ Failed'}`
              }).catch(e => {
                // This might fail for workflow_dispatch events, which is fine
                console.log('Note: Could not add comment to workflow run');
              });
            } catch (error) {
              console.error(`Error creating gist: ${error.message}`);
            } 